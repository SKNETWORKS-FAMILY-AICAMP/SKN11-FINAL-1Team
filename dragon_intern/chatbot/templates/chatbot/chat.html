<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>💬 MCP 도구 활용 에이전트</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Streamlit과 유사한 스타일링 */
        .sidebar {
            background-color: #f8f9fa;
            border-right: 1px solid #e9ecef;
        }
        .chat-container {
            height: 70vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- CSRF 토큰을 메타 태그로 추가 -->
    {% csrf_token %}
    <meta name="csrf-token" content="{{ csrf_token }}">
    
    <div class="flex h-screen">
        <!-- 사이드바 (Streamlit sidebar와 동일한 구조) -->
        <div class="sidebar w-1/4 p-4 overflow-y-auto">
            <div class="mb-4">
                <h3 class="text-lg font-bold">✍️ Made by <a href="https://youtube.com/c/teddynote" class="text-blue-600">테디노트</a> 🚀</h3>
                <p class="text-sm">💻 <a href="https://github.com/teddynote-lab/langgraph-mcp-agents" class="text-blue-600">Project Page</a></p>
            </div>
            
            <hr class="my-4">
            
            <!-- 시스템 설정 -->
            <div class="mb-6">
                <h4 class="font-bold mb-2">⚙️ 시스템 설정</h4>
                <select id="modelSelect" class="w-full p-2 border rounded">
                    {% for model in available_models %}
                    <option value="{{ model }}">{{ model }}</option>
                    {% endfor %}
                </select>
                
                <div class="mt-4">
                    <label class="block text-sm font-medium">⏱️ 응답 생성 제한 시간(초)</label>
                    <input type="range" id="timeoutSlider" min="60" max="300" value="120" class="w-full">
                    <span id="timeoutValue">120</span>
                </div>
            </div>
            
            <hr class="my-4">
            
            <!-- 도구 설정 -->
            <div class="mb-6">
                <h4 class="font-bold mb-2">🔧 도구 설정</h4>
                <details class="border rounded p-2">
                    <summary class="cursor-pointer">🧰 MCP 도구 추가</summary>
                    <div class="mt-2">
                        <textarea id="toolConfig" class="w-full h-40 p-2 border rounded text-sm" 
                                  placeholder='{"도구이름": {"command": "...", "args": [...]}}'></textarea>
                        <button onclick="addTool()" class="w-full mt-2 bg-blue-500 text-white p-2 rounded">도구 추가</button>
                    </div>
                </details>
                
                <!-- 등록된 도구 목록 -->
                <div class="mt-4">
                    <h5 class="font-medium">📋 등록된 도구 목록</h5>
                    <div id="toolList">
                        {% for tool in mcp_tools %}
                        <div class="flex justify-between items-center py-1">
                            <span>- <strong>{{ tool.name }}</strong></span>
                            <button onclick="deleteTool('{{ tool.name }}')" class="text-red-500 text-sm">삭제</button>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            
            <hr class="my-4">
            
            <!-- 시스템 정보 및 작업 버튼 -->
            <div>
                <h4 class="font-bold mb-2">📊 시스템 정보</h4>
                <p class="text-sm">🛠️ MCP 도구 수: <span id="toolCount">{{ mcp_tools.count }}</span></p>
                <p class="text-sm">🧠 현재 모델: <span id="currentModel">claude-3-7-sonnet-latest</span></p>
                
                <button onclick="applySettings()" id="applySettingsBtn" class="w-full mt-4 bg-green-500 text-white p-2 rounded">설정 적용하기</button>
                <button onclick="clearChat()" class="w-full mt-2 bg-gray-500 text-white p-2 rounded">대화 초기화</button>
            </div>
        </div>
        
        <!-- 메인 채팅 영역 -->
        <div class="flex-1 flex flex-col">
            <header class="bg-white shadow-sm p-4">
                <h1 class="text-2xl font-bold">💬 MCP 도구 활용 에이전트</h1>
                <p class="text-gray-600">✨ MCP 도구를 활용한 ReAct 에이전트에게 질문해보세요.</p>
            </header>
            
            <!-- 채팅 메시지 영역 -->
            <div id="chatMessages" class="chat-container flex-1 p-4 space-y-4">
                <!-- 채팅 메시지들이 여기에 동적으로 추가됩니다 -->
            </div>
            
            <!-- 메시지 입력 영역 -->
            <div class="bg-white border-t p-4">
                <div class="flex space-x-2">
                    <textarea id="messageInput"
                              placeholder="💬 질문을 입력하세요"
                              rows="2"
                              class="flex-1 p-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y min-h-[48px] max-h-40"></textarea>
                    <button onclick="sendMessage()"
                            class="bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600">전송</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        async function initializeMCP() {
            try {
                const response = await fetch('/initialize-mcp/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('toolCount').textContent = data.tool_count;
                    console.log('✅ MCP initialized:', data.tools);
                    
                    // 도구 목록 업데이트
                    updateToolList(data.tools);
                } else {
                    console.error('❌ MCP initialization failed:', data.error);
                    alert('MCP 초기화에 실패했습니다: ' + data.error);
                }
            } catch (error) {
                console.error('❌ MCP initialization error:', error);
                alert('MCP 초기화 중 오류가 발생했습니다.');
            }
        }

        async function addTool() {
            const configText = document.getElementById('toolConfig').value;
            
            try {
                const config = JSON.parse(configText);
                
                const response = await fetch('/save-config/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(config)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert('도구가 성공적으로 추가되었습니다!');
                    location.reload(); // 페이지 새로고침
                } else {
                    alert('도구 추가 실패: ' + data.error);
                }
            } catch (error) {
                alert('JSON 형식이 올바르지 않습니다: ' + error.message);
            }
        }

        async function deleteTool(toolName) {
            if (confirm(`${toolName} 도구를 삭제하시겠습니까?`)) {
                try {
                    const response = await fetch('/delete-tool/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({tool_name: toolName})
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        alert('도구가 성공적으로 삭제되었습니다!');
                        location.reload();
                    } else {
                        alert('도구 삭제 실패: ' + data.error);
                    }
                } catch (error) {
                    alert('오류가 발생했습니다: ' + error.message);
                }
            }
        }

        // 설정 적용 함수 (하나만 유지, 중복 제거)
        async function applySettings() {
            const btn = document.getElementById('applySettingsBtn');
            if (!btn) {
                console.error('❌ applySettingsBtn을 찾을 수 없습니다.');
                return;
            }
            
            const originalText = btn.textContent;
            
            // 버튼 상태 변경
            btn.disabled = true;
            btn.textContent = '적용 중...';
            btn.className = 'w-full mt-4 bg-gray-400 text-white p-2 rounded cursor-not-allowed';
            
            try {
                console.log('🔄 설정 적용 시작...');
                
                // 사용자 선택 설정 정보 수집 (중요: 모델 선택 정보 포함)
                const selectedModel = document.getElementById('modelSelect').value;
                const timeoutSeconds = parseInt(document.getElementById('timeoutSlider').value);
                
                console.log(`🎯 선택된 모델: ${selectedModel}`);
                
                // CSRF 토큰 가져오기
                const csrftoken = getCookie('csrftoken') || 
                                document.querySelector('[name=csrfmiddlewaretoken]')?.value ||
                                document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
                
                const headers = {
                    'Content-Type': 'application/json',
                };
                
                if (csrftoken) {
                    headers['X-CSRFToken'] = csrftoken;
                }
                
                const response = await fetch('/apply-settings/', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        'action': 'apply_settings',
                        'selected_model': selectedModel,  // 선택된 모델 정보 전송
                        'timeout_seconds': timeoutSeconds,
                        'timestamp': new Date().toISOString()
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${response.statusText}\n${errorText}`);
                }
                
                const data = await response.json();
                console.log('✅ 서버 응답:', data);
                
                if (data.success) {
                    alert('✅ 설정이 성공적으로 적용되었습니다!');
                    document.getElementById('toolCount').textContent = data.tool_count || 0;
                    
                    // 현재 모델 정보 업데이트 (세션에서 모델 선택 정보 유지 확인)
                    if (data.user_settings && data.user_settings.selected_model) {
                        document.getElementById('currentModel').textContent = data.user_settings.selected_model;
                        document.getElementById('modelSelect').value = data.user_settings.selected_model;
                        console.log(`✅ 모델 선택 정보 유지 확인: ${data.user_settings.selected_model}`);
                    }
                    
                } else {
                    throw new Error(data.error || '알 수 없는 오류가 발생했습니다.');
                }
                
            } catch (error) {
                console.error('❌ 설정 적용 오류:', error);
                alert('❌ 설정 적용 실패: ' + error.message);
            } finally {
                // 버튼 상태 복원
                btn.disabled = false;
                btn.textContent = originalText;
                btn.className = 'w-full mt-4 bg-green-500 text-white p-2 rounded hover:bg-green-600';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            // 1️⃣ WebSocket robust 연결 설정 (중복 제거, auto-reconnect)
            let chatSocket = null;
            let reconnectAttempts = 0;
            const maxReconnectAttempts = 5;
            let reconnectTimeout = null;
            let currentAssistantMessage = '';
            let assistantMessageDiv = null;

            function connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                chatSocket = new WebSocket(protocol + '//' + window.location.host + '/ws/chat/');

                chatSocket.onopen = function() {
                    reconnectAttempts = 0;
                    console.log('✅ WebSocket 연결됨');
                };

                chatSocket.onmessage = function(e) {
                    const data = JSON.parse(e.data);
                    console.log('📩 WebSocket 메시지 수신:', data);
                    if (data.role === 'user') {
                        displayMessage(data);
                    } else if (data.role === 'assistant_stream') {
                        // 스트리밍 응답 처리
                        if (!assistantMessageDiv) {
                            assistantMessageDiv = createAssistantMessageDiv();
                            document.getElementById('chatMessages').appendChild(assistantMessageDiv);
                        }
                        currentAssistantMessage += data.content;
                        updateAssistantMessage(assistantMessageDiv, currentAssistantMessage);
                    } else if (data.role === 'system' && data.content === '✅ 응답 완료') {
                        // 답변이 모두 끝난 뒤 후처리: JSON 코드블럭 토글 등 적용
                        if (assistantMessageDiv && currentAssistantMessage) {
                            const contentP = assistantMessageDiv.querySelector('.assistant-content');
                            if (window.marked) {
                                contentP.innerHTML = renderMarkdownWithJsonToggle(currentAssistantMessage);
                            } else {
                                contentP.textContent = currentAssistantMessage;
                            }
                        }
                        assistantMessageDiv = null;
                        currentAssistantMessage = '';
                    } else {
                        displayMessage(data);
                    }
                };

                chatSocket.onclose = function(e) {
                    console.error('❌ WebSocket 연결 종료됨', e);
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = 1000 * reconnectAttempts;
                        reconnectTimeout = setTimeout(connectWebSocket, delay);
                        console.warn(`재연결 시도 ${reconnectAttempts}/${maxReconnectAttempts}...`);
                    } else {
                        alert('WebSocket 연결이 반복적으로 끊어졌습니다. 새로고침 해주세요.');
                    }
                };

                chatSocket.onerror = function(e) {
                    console.error('❌ WebSocket 오류:', e);
                    chatSocket.close();
                };
            }

            connectWebSocket();

            // 2️⃣ WebSocket 기반 메시지 전송 함수 (단일 정의, robust)
            window.sendMessage = function() {
                const input = document.getElementById('messageInput');
                const message = input.value.trim();
                if (!message) return;
                if (!chatSocket || chatSocket.readyState !== 1) {
                    alert('WebSocket 연결이 불안정합니다. 잠시 후 다시 시도하세요.');
                    return;
                }
                chatSocket.send(JSON.stringify({ 'message': message }));
                input.value = '';
            };

            // 3️⃣ 세션에서 사용자 설정 복원 (기존 로직 유지)
            fetch('/get-user-settings/')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.user_settings) {
                        console.log('🔄 세션에서 사용자 설정 복원:', data.user_settings);
                        
                        // 모델 선택 복원
                        const modelSelect = document.getElementById('modelSelect');
                        if (modelSelect && data.user_settings.selected_model) {
                            modelSelect.value = data.user_settings.selected_model;
                            document.getElementById('currentModel').textContent = data.user_settings.selected_model;
                            console.log(`✅ 모델 선택 복원: ${data.user_settings.selected_model}`);
                        }
                        
                        // 타임아웃 설정 복원
                        if (data.user_settings.timeout_seconds) {
                            document.getElementById('timeoutSlider').value = data.user_settings.timeout_seconds;
                            document.getElementById('timeoutValue').textContent = data.user_settings.timeout_seconds;
                        }
                        
                        // 도구 수 복원
                        if (data.user_settings.tool_count) {
                            document.getElementById('toolCount').textContent = data.user_settings.tool_count;
                        }
                    }
                })
                .catch(error => console.error('사용자 설정 로드 오류:', error));
            
            // 4️⃣ MCP 초기화 (기존 로직 유지)
            initializeMCP();
        });

        // CSRF 토큰 가져오기
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        const csrftoken = getCookie('csrftoken');

        function updateToolList(tools) {
            const toolListDiv = document.getElementById('toolList');
            toolListDiv.innerHTML = '';
            
            tools.forEach(toolName => {
                const toolDiv = document.createElement('div');
                toolDiv.className = 'flex justify-between items-center py-1';
                toolDiv.innerHTML = `
                    <span>- <strong>${toolName}</strong></span>
                    <button onclick="deleteTool('${toolName}')" class="text-red-500 text-sm">삭제</button>
                `;
                toolListDiv.appendChild(toolDiv);
            });
        }

        // Enter/Shift+Enter 입력 처리 (textarea용)
        document.getElementById('messageInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    // 줄바꿈 허용
                    return;
                } else {
                    e.preventDefault();
                    sendMessage();
                }
            }
        });

        function createAssistantMessageDiv() {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex justify-start';
            messageDiv.innerHTML = `
                <div class="bg-white border p-3 rounded-lg max-w-3xl">
                    <div class="flex items-center mb-1">
                        <span class="mr-2">🤖</span>
                        <span class="font-medium">어시스턴트</span>
                    </div>
                    <p class="assistant-content"></p>
                </div>
            `;
            return messageDiv;
        }

        function renderMarkdownWithJsonToggle(markdownText) {
            // marked로 HTML 변환
            let html = window.marked.parse(markdownText);
            // JSON 코드블럭을 토글 가능한 div로 변환
            html = html.replace(/<pre><code class="language-json">([\s\S]*?)<\/code><\/pre>/g, function(match, p1) {
                const jsonText = p1.replace(/&quot;/g, '"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
                const id = 'json-toggle-' + Math.random().toString(36).substr(2, 9);
                return `
                <div class="json-toggle-block border rounded bg-gray-100 my-2">
                    <button onclick="const e=document.getElementById('${id}');e.style.display=e.style.display==='none'?'block':'none';this.textContent=e.style.display==='none'?'코드 보기 ▼':'코드 숨기기 ▲';" class="text-xs text-blue-600 px-2 py-1">코드 보기 ▼</button>
                    <pre id="${id}" style="display:none;overflow-x:auto;"><code class="language-json">${jsonText}</code></pre>
                </div>
                `;
            });
            return html;
        }

        function updateAssistantMessage(messageDiv, content) {
            const contentP = messageDiv.querySelector('.assistant-content');
            if (window.marked) {
                // 스트리밍 중에는 마크다운만 빠르게 렌더링 (JSON 토글 후처리는 마지막에만)
                contentP.innerHTML = window.marked.parse(content);
            } else {
                contentP.textContent = content;
            }
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function displayMessage(data) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            if (data.role === 'user') {
                messageDiv.className = 'flex justify-end';
                messageDiv.innerHTML = `
                    <div class="bg-blue-500 text-white p-3 rounded-lg max-w-3xl">
                        <div class="flex items-center mb-1">
                            <span class="mr-2">🧑‍💻</span>
                            <span class="font-medium">사용자</span>
                        </div>
                        <p style="white-space: pre-line;">${data.content}</p>
                    </div>
                `;
            } else {
                messageDiv.className = 'flex justify-start';
                messageDiv.innerHTML = `
                    <div class="bg-white border p-3 rounded-lg max-w-3xl">
                        <div class="flex items-center mb-1">
                            <span class="mr-2">🤖</span>
                            <span class="font-medium">어시스턴트</span>
                        </div>
                        <p class="assistant-content"></p>
                    </div>
                `;
                const contentP = messageDiv.querySelector('.assistant-content');
                if (window.marked) {
                    contentP.innerHTML = renderMarkdownWithJsonToggle(data.content);
                } else {
                    contentP.textContent = data.content;
                }
            }
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // 유틸리티 함수들
        async function clearChat() {
            try {
                const response = await fetch('/clear-chat/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken'),
                    }
                });
                
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('chatMessages').innerHTML = '';
                    alert('대화가 초기화되었습니다.');
                } else {
                    alert('대화 초기화 실패: ' + data.error);
                }
            } catch (error) {
                alert('오류가 발생했습니다: ' + error.message);
            }
        }

        // marked.js CDN 추가 (마크다운 파싱용)
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js';
        document.head.appendChild(script);
    </script>
</body>
</html>
